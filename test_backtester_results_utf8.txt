FFF.                                                                     [100%]
================================== FAILURES ===================================
_____________________ test_backtester_execution_pipeline ______________________

tmp_path = WindowsPath('C:/Users/Praveen P/AppData/Local/Temp/pytest-of-Praveen P/pytest-14/test_backtester_execution_pipe0')

    def test_backtester_execution_pipeline(tmp_path):
        provider = MockProvider()
    
        # Execution handler with visible costs & participation constraints
        execution = RealisticExecutionHandler(
            commission_pct=0.002,
            max_participation_rate=0.05,
            impact_coeff=0.20,
            adv_lookback=3,
            vol_lookback=3,
            min_vol_fallback=0.01,
        )
    
        engine = BacktestEngine(
            provider=provider,
            initial_capital=1_000_000.0,
            execution_handler=execution,
        )
    
        # -----------------------------------------------------
        # Strategy: intentionally oversized order \u2192 partial fill
        # -----------------------------------------------------
        def strategy_fn(timestamp, prices, engine_ref):
            blotter = engine_ref.get_blotter()
            # Execution handler requires min 5 bars of history for volatility calc.
            # MockProvider starts Jan 2. We wait until we have enough history.
            # Jan 2, 3, 4, 5, 6, 9...
            if blotter.orders_df().empty and timestamp.day > 9:
                # Request more than participation allows
                return [Order("TEST", 20_000, OrderType.MARKET, timestamp)]
            return []
    
        # -----------------------------------------------------
        # Run engine (institutional signature)
        # -----------------------------------------------------
>       engine.run(
            start_date="2023-01-02",
            tickers=["TEST"],
            strategy_fn=strategy_fn,
        )

tests\test_backtester.py:102: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <backtest.engine.BacktestEngine object at 0x00000134CC5D8110>
start_date = '2023-01-02'
strategy_fn = <function test_backtester_execution_pipeline.<locals>.strategy_fn at 0x00000134CC5D1300>
tickers = ['TEST'], end_date = None

    def run(self, start_date: str, strategy_fn: Callable, tickers: List[str], end_date: Optional[str] = None) -> None:
        """
        Run the backtest.
    
        - start_date/end_date: "YYYY-MM-DD"
        - strategy_fn: callable(timestamp, prices, engine) -> list[Order]
        - tickers: list of symbols to fetch and iterate
        """
        if not tickers:
            raise ValueError("tickers must be provided to run()")
    
        full_panel = self._build_price_panel(tickers, start_date, end_date)
        if full_panel is None or full_panel.empty:
            raise RuntimeError("Price panel empty.")
    
        # Filter iteration to start at start_date, but keep full_panel for .loc[:ts] lookbacks
        trading_panel = full_panel[full_panel.index >= pd.to_datetime(start_date)]
        if trading_panel.empty:
>           raise RuntimeError(f"No trading data available starting at {start_date}")
E           RuntimeError: No trading data available starting at 2023-01-02

backtest\engine.py:226: RuntimeError
__________________________ test_integrity_invariants __________________________

tmp_path = WindowsPath('C:/Users/Praveen P/AppData/Local/Temp/pytest-of-Praveen P/pytest-14/test_integrity_invariants0')

    def test_integrity_invariants(tmp_path):
        """
        Validation Fix #1: Hard State Invariants
        Verify engine raises RuntimeError immediately if accounting state becomes NaN.
        """
        provider = MockProvider()
        engine = BacktestEngine(
            provider=provider,
            initial_capital=1_000_000.0,
            execution_handler=RealisticExecutionHandler()
        )
    
        # Strategy that injects corruption into accessors if possible,
        # or relies on engine check. Since we can't easily injection-attack the engine's private state
        # from strategy without naughty hacks, we'll try to force a bad trade
        # or rely on the MockProvider yielding NaNs to see if engine catches it.
    
        # 1. Test NaN in Price Data (Fix #8 Deterministic Failure)
        class CorruptProvider:
            def get_panel(self, tickers, start_date, end_date=None):
                dates = pd.date_range(start=start_date, periods=5, freq="B")
                data = {}
                for tk in tickers:
                    # Day 3 has NaN price
                    prices = np.array([100.0, 101.0, np.nan, 103.0, 104.0])
                    data[(tk, "Open")] = prices
                    data[(tk, "High")] = prices + 1
                    data[(tk, "Low")] = prices - 1
                    data[(tk, "Close")] = prices
                    data[(tk, "Volume")] = np.full(5, 1000.0)
    
                df = pd.DataFrame(data, index=dates)
                df.columns = pd.MultiIndex.from_tuples(df.columns)
                return df
    
        engine_corrupt = BacktestEngine(provider=CorruptProvider(), initial_capital=100_000)
    
        def no_op_strategy(ts, prices, eng):
            return []
    
        # Should detect NaN in _validate_state or during bar processing
        # The current engine implementation might skip invalid data in bar processing,
        # but _validate_state calls _portfolio_value which raises RuntimeError if price is NaN.
    
        try:
>           engine_corrupt.run("2023-01-01", tickers=["TEST"], strategy_fn=no_op_strategy)

tests\test_backtester.py:248: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <backtest.engine.BacktestEngine object at 0x00000134CC73C890>
start_date = '2023-01-01'
strategy_fn = <function test_integrity_invariants.<locals>.no_op_strategy at 0x00000134CC651300>
tickers = ['TEST'], end_date = None

    def run(self, start_date: str, strategy_fn: Callable, tickers: List[str], end_date: Optional[str] = None) -> None:
        """
        Run the backtest.
    
        - start_date/end_date: "YYYY-MM-DD"
        - strategy_fn: callable(timestamp, prices, engine) -> list[Order]
        - tickers: list of symbols to fetch and iterate
        """
        if not tickers:
            raise ValueError("tickers must be provided to run()")
    
        full_panel = self._build_price_panel(tickers, start_date, end_date)
        if full_panel is None or full_panel.empty:
            raise RuntimeError("Price panel empty.")
    
        # Filter iteration to start at start_date, but keep full_panel for .loc[:ts] lookbacks
        trading_panel = full_panel[full_panel.index >= pd.to_datetime(start_date)]
        if trading_panel.empty:
>           raise RuntimeError(f"No trading data available starting at {start_date}")
E           RuntimeError: No trading data available starting at 2023-01-01

backtest\engine.py:226: RuntimeError

During handling of the above exception, another exception occurred:

tmp_path = WindowsPath('C:/Users/Praveen P/AppData/Local/Temp/pytest-of-Praveen P/pytest-14/test_integrity_invariants0')

    def test_integrity_invariants(tmp_path):
        """
        Validation Fix #1: Hard State Invariants
        Verify engine raises RuntimeError immediately if accounting state becomes NaN.
        """
        provider = MockProvider()
        engine = BacktestEngine(
            provider=provider,
            initial_capital=1_000_000.0,
            execution_handler=RealisticExecutionHandler()
        )
    
        # Strategy that injects corruption into accessors if possible,
        # or relies on engine check. Since we can't easily injection-attack the engine's private state
        # from strategy without naughty hacks, we'll try to force a bad trade
        # or rely on the MockProvider yielding NaNs to see if engine catches it.
    
        # 1. Test NaN in Price Data (Fix #8 Deterministic Failure)
        class CorruptProvider:
            def get_panel(self, tickers, start_date, end_date=None):
                dates = pd.date_range(start=start_date, periods=5, freq="B")
                data = {}
                for tk in tickers:
                    # Day 3 has NaN price
                    prices = np.array([100.0, 101.0, np.nan, 103.0, 104.0])
                    data[(tk, "Open")] = prices
                    data[(tk, "High")] = prices + 1
                    data[(tk, "Low")] = prices - 1
                    data[(tk, "Close")] = prices
                    data[(tk, "Volume")] = np.full(5, 1000.0)
    
                df = pd.DataFrame(data, index=dates)
                df.columns = pd.MultiIndex.from_tuples(df.columns)
                return df
    
        engine_corrupt = BacktestEngine(provider=CorruptProvider(), initial_capital=100_000)
    
        def no_op_strategy(ts, prices, eng):
            return []
    
        # Should detect NaN in _validate_state or during bar processing
        # The current engine implementation might skip invalid data in bar processing,
        # but _validate_state calls _portfolio_value which raises RuntimeError if price is NaN.
    
        try:
            engine_corrupt.run("2023-01-01", tickers=["TEST"], strategy_fn=no_op_strategy)
        except RuntimeError as e:
>           assert "Cannot compute equity: missing price" in str(e) or "INVARIANT VIOLATION" in str(e) or "NaN" in str(e)
E           AssertionError: assert ('Cannot compute equity: missing price' in 'No trading data available starting at 2023-01-01' or 'INVARIANT VIOLATION' in 'No trading data available starting at 2023-01-01' or 'NaN' in 'No trading data available starting at 2023-01-01')
E            +  where 'No trading data available starting at 2023-01-01' = str(RuntimeError('No trading data available starting at 2023-01-01'))
E            +  and   'No trading data available starting at 2023-01-01' = str(RuntimeError('No trading data available starting at 2023-01-01'))
E            +  and   'No trading data available starting at 2023-01-01' = str(RuntimeError('No trading data available starting at 2023-01-01'))

tests\test_backtester.py:250: AssertionError
_______________________ test_risk_kill_switch_authority _______________________

    def test_risk_kill_switch_authority():
        """
        Validation Fix #3: Kill-Switch Authority
        Validation Fix #4: Remove Silent Fallbacks
        Verify that if Strategy (via RiskManager) raises RuntimeError, the Engine CRASHES (does not swallow).
        """
        provider = MockProvider()
        engine = BacktestEngine(provider=provider, initial_capital=1_000_000.0)
    
        def kamikaze_strategy(ts, prices, eng):
            # Simulate RiskManager.check_portfolio_risk returning FREEZE -> raising RuntimeError
            raise RuntimeError("RISK KILL-SWITCH: LEVERAGE EXCEEDED")
    
        try:
>           engine.run("2023-01-01", tickers=["TEST"], strategy_fn=kamikaze_strategy)

tests\test_backtester.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <backtest.engine.BacktestEngine object at 0x00000134CC6B8850>
start_date = '2023-01-01'
strategy_fn = <function test_risk_kill_switch_authority.<locals>.kamikaze_strategy at 0x00000134CC651620>
tickers = ['TEST'], end_date = None

    def run(self, start_date: str, strategy_fn: Callable, tickers: List[str], end_date: Optional[str] = None) -> None:
        """
        Run the backtest.
    
        - start_date/end_date: "YYYY-MM-DD"
        - strategy_fn: callable(timestamp, prices, engine) -> list[Order]
        - tickers: list of symbols to fetch and iterate
        """
        if not tickers:
            raise ValueError("tickers must be provided to run()")
    
        full_panel = self._build_price_panel(tickers, start_date, end_date)
        if full_panel is None or full_panel.empty:
            raise RuntimeError("Price panel empty.")
    
        # Filter iteration to start at start_date, but keep full_panel for .loc[:ts] lookbacks
        trading_panel = full_panel[full_panel.index >= pd.to_datetime(start_date)]
        if trading_panel.empty:
>           raise RuntimeError(f"No trading data available starting at {start_date}")
E           RuntimeError: No trading data available starting at 2023-01-01

backtest\engine.py:226: RuntimeError

During handling of the above exception, another exception occurred:

    def test_risk_kill_switch_authority():
        """
        Validation Fix #3: Kill-Switch Authority
        Validation Fix #4: Remove Silent Fallbacks
        Verify that if Strategy (via RiskManager) raises RuntimeError, the Engine CRASHES (does not swallow).
        """
        provider = MockProvider()
        engine = BacktestEngine(provider=provider, initial_capital=1_000_000.0)
    
        def kamikaze_strategy(ts, prices, eng):
            # Simulate RiskManager.check_portfolio_risk returning FREEZE -> raising RuntimeError
            raise RuntimeError("RISK KILL-SWITCH: LEVERAGE EXCEEDED")
    
        try:
            engine.run("2023-01-01", tickers=["TEST"], strategy_fn=kamikaze_strategy)
        except RuntimeError as e:
>           assert "RISK KILL-SWITCH" in str(e)
E           AssertionError: assert 'RISK KILL-SWITCH' in 'No trading data available starting at 2023-01-01'
E            +  where 'No trading data available starting at 2023-01-01' = str(RuntimeError('No trading data available starting at 2023-01-01'))

tests\test_backtester.py:275: AssertionError
=========================== short test summary info ===========================
FAILED tests/test_backtester.py::test_backtester_execution_pipeline - Runtime...
FAILED tests/test_backtester.py::test_integrity_invariants - AssertionError: ...
FAILED tests/test_backtester.py::test_risk_kill_switch_authority - AssertionE...
3 failed, 1 passed in 1.55s
