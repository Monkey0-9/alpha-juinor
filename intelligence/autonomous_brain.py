"""
Autonomous Trading Brain - The Ultimate Controller
=====================================================

This is the SUPREME trading intelligence that:
1. Analyzes market regime precisely
2. Selects from 13+ strategies automatically
3. Detects smart money flow
4. Generates high-conviction trades
5. Manages risk dynamically
6. Operates fully autonomously

This is TOP 1% hedge fund level intelligence.
"""

import logging
from dataclasses import dataclass
from datetime import datetime
from decimal import Decimal, getcontext
from typing import Any, Dict, List, Optional

import pandas as pd

from config.ml_config import MLConfig

logger = logging.getLogger(__name__)

getcontext().prec = 50


@dataclass
class AutonomousTrade:
    """A trade generated by the autonomous brain."""

    timestamp: datetime

    # Trade details
    symbol: str
    action: str  # BUY, SELL, SHORT

    # Entry
    entry_price: Decimal
    entry_type: str  # MARKET, LIMIT, VWAP

    # Position
    position_size: Decimal  # As % of portfolio
    shares: int

    # Exits
    stop_loss: Decimal
    take_profit_1: Decimal
    take_profit_2: Decimal
    take_profit_3: Decimal

    # Risk
    risk_pct: Decimal
    reward_pct: Decimal
    risk_reward: Decimal
    max_loss_dollars: Decimal

    # Decision info
    strategy_used: str
    regime: str
    confidence: float
    grade: str  # A+, A, B

    # Reasoning
    reasoning: List[str]
    smart_money_aligned: bool

    # Validation
    all_checks_passed: bool


class AutonomousTradingBrain:
    """
    The ULTIMATE autonomous trading intelligence.

    Combines ALL modules for fully autonomous operation:
    - Regime Analysis
    - Strategy Selection (13+ strategies)
    - Smart Money Detection
    - Risk Management
    - Trade Generation

    Operates at TOP 1% hedge fund level.
    """

    # Risk thresholds
    MAX_POSITION_SIZE = Decimal("0.10")  # 10% max per trade
    MIN_RISK_REWARD = 2.5
    MIN_CONFIDENCE = 0.70
    MAX_LOSS_PER_TRADE = Decimal("0.05")  # 5% max loss

    def __init__(self):
        """Initialize the autonomous brain."""
        self._init_all_modules()

        self.trades_generated = 0
        self.trades_executed = 0
        self.winning_trades = 0

        logger.info(
            "[AUTONOMOUS] Autonomous Trading Brain initialized - "
            "TOP 1% INTELLIGENCE ACTIVE"
        )

    def _init_all_modules(self):
        """Initialize all intelligence modules."""
        # Regime Analyzer
        try:
            from analytics.regime_analyzer import get_regime_analyzer

            self._regime = get_regime_analyzer()
            logger.info("[AUTONOMOUS] Regime Analyzer loaded")
        except Exception as e:
            logger.warning(f"[AUTONOMOUS] Regime not available: {e}")
            self._regime = None

        # Strategy Universe (10 base strategies)
        try:
            from strategies.strategy_universe import get_strategy_universe

            self._universe = get_strategy_universe()
            logger.info("[AUTONOMOUS] Strategy Universe loaded (10 strategies)")
        except Exception as e:
            logger.warning(f"[AUTONOMOUS] Universe not available: {e}")
            self._universe = None

        # Institutional Strategies (10 more)
        try:
            from strategies.institutional_strategies import get_institutional_hub

            self._institutional = get_institutional_hub()
            logger.info("[AUTONOMOUS] Institutional Hub loaded (10 strategies)")
        except Exception as e:
            logger.warning(f"[AUTONOMOUS] Institutional not available: {e}")
            self._institutional = None

        # Aggressive Strategies
        try:
            from strategies.aggressive_recovery import get_hrhr_engine

            self._hrhr = get_hrhr_engine()
            logger.info("[AUTONOMOUS] High Risk High Reward loaded")
        except Exception as e:
            logger.warning(f"[AUTONOMOUS] HRHR not available: {e}")
            self._hrhr = None

        # Dip Buyer
        try:
            from strategies.dip_buyer import get_dip_buyer

            self._dip_buyer = get_dip_buyer()
            logger.info("[AUTONOMOUS] Dip Buyer loaded")
        except Exception as e:
            logger.warning(f"[AUTONOMOUS] Dip Buyer not available: {e}")
            self._dip_buyer = None

        # Smart Money
        try:
            from intelligence.smart_money_detector import get_smart_money_detector

            self._smart_money = get_smart_money_detector()
            logger.info("[AUTONOMOUS] Smart Money Detector loaded")
        except Exception as e:
            logger.warning(f"[AUTONOMOUS] Smart Money not available: {e}")
            self._smart_money = None

        # Zero Loss Guardian
        try:
            from intelligence.zero_loss_guardian import get_guardian

            self._guardian = get_guardian()
            logger.info("[AUTONOMOUS] Zero Loss Guardian loaded")
        except Exception as e:
            logger.warning(f"[AUTONOMOUS] Guardian not available: {e}")
            self._guardian = None

        # Precision Analyzer
        try:
            from analytics.precision_analyzer import get_precision_analyzer

            self._precision = get_precision_analyzer()
            logger.info("[AUTONOMOUS] Precision Analyzer loaded")
        except Exception as e:
            logger.warning(f"[AUTONOMOUS] Precision not available: {e}")
            self._precision = None

        # Predictive Alpha (ML)
        try:
            from ml_alpha.predictive_model import PredictiveModel

            self._predictive_model = PredictiveModel()
            logger.info("[AUTONOMOUS] Predictive Model (ML-Alpha) loaded")
        except Exception as e:
            logger.warning(f"[AUTONOMOUS] Predictive Model not available: {e}")
            self._predictive_model = None

    def think_and_trade(
        self,
        market_data: pd.DataFrame,
        fundamentals: Optional[Dict[str, Dict]] = None,
        portfolio_value: float = 100000,
    ) -> List[AutonomousTrade]:
        """
        Main autonomous trading method.

        Analyzes everything and generates optimal trades.
        """
        trades = []

        # STEP 1: Analyze market regime
        regime_info = self._analyze_regime(market_data)

        all_signals = []

        # STEP 2 (NEW): Scan SMC Opportunities (Priority 1)
        # Goal: 70% of candidates from SMC
        smc_signals = self._scan_smc_opportunities(market_data)
        all_signals.extend(smc_signals)

        # STEP 3: Gather signals from ALL strategies (Priority 2)
        other_signals = self._gather_all_signals(market_data, fundamentals, regime_info)
        all_signals.extend(other_signals)

        # STEP 4: Detect smart money activity (Legacy Flags)
        smart_money_signals = self._detect_smart_money(market_data)

        # STEP 5: Combine and rank opportunities
        candidates = self._rank_opportunities(
            all_signals, smart_money_signals, regime_info, market_data
        )

        # STEP 6: Validate and generate trades
        for candidate in candidates[:10]:  # Top 10 candidates
            trade = self._generate_trade(
                candidate, market_data, regime_info, portfolio_value
            )
            if trade and trade.all_checks_passed:
                trades.append(trade)

        # Log summary
        if trades:
            logger.info(
                f"[AUTONOMOUS] Generated {len(trades)} trades | "
                f"Regime: {regime_info.get('primary', 'UNKNOWN')} | "
                f"Strategies used: {len(set(t.strategy_used for t in trades))}"
            )

        self.trades_generated += len(trades)

        return trades

    def _scan_smc_opportunities(self, market_data: pd.DataFrame) -> List[Dict]:
        """Scan market for SMC opportunities first."""
        signals = []
        if not self._smart_money:
            return signals

        # Iterate symbols
        if isinstance(market_data.columns, pd.MultiIndex):
            symbols = list(market_data.columns.get_level_values(0).unique())
        else:
            return signals

        for symbol in symbols:
            try:
                df = market_data[symbol]
                # Ensure we have required columns
                if not all(
                    col in df.columns
                    for col in ["Open", "High", "Low", "Close", "Volume"]
                ):
                    continue

                # Call method
                opps = self._smart_money.detect_smc_opportunities(
                    symbol, df["Close"], df["Volume"], df["High"], df["Low"], df["Open"]
                )

                for opp in opps:
                    # Map to signal schema
                    action = "NEUTRAL"
                    if opp.type in ["BullishOB", "BullishHunt"]:
                        action = "BUY"
                    elif opp.type in ["BearishOB", "BearishHunt"]:
                        action = "SELL"
                    elif opp.type == "LiquidityGap":
                        # Logic: If price is above gap, it's support (BUY bounce)
                        # If price is below gap, it's resistance (SELL reject)
                        curr_price = df["Close"].iloc[-1]
                        if curr_price > opp.level:
                            action = "BUY"  # Bounce off FVG support
                        else:
                            action = "SELL"  # Reject from FVG resistance

                    signals.append(
                        {
                            "source": "SMC_NATIVE",
                            "strategy": opp.type,
                            "symbol": opp.symbol,
                            "action": action,
                            "entry": Decimal(str(opp.level)),
                            "stop": (
                                Decimal(str(opp.level * 0.98))
                                if action == "BUY"
                                else Decimal(str(opp.level * 1.02))
                            ),  # Temp logic
                            "target": (
                                Decimal(str(opp.level * 1.05))
                                if action == "BUY"
                                else Decimal(str(opp.level * 0.95))
                            ),
                            "confidence": opp.confidence,
                            "reasoning": f"SMC {opp.type} detected on {opp.timeframe} at {opp.level}",
                            "smart_money_aligned": True,  # By definition
                        }
                    )

            except Exception:
                continue

        return signals

    def _analyze_regime(self, market_data: pd.DataFrame) -> Dict[str, Any]:
        """Analyze current market regime."""
        if self._regime:
            try:
                analysis = self._regime.analyze(market_data)
                return {
                    "primary": analysis.primary_regime.value,
                    "secondary": (
                        analysis.secondary_regime.value
                        if analysis.secondary_regime
                        else None
                    ),
                    "confidence": analysis.regime_confidence,
                    "trend": analysis.trend_strength,
                    "volatility": analysis.volatility_percentile,
                    "risk_mult": analysis.risk_multiplier,
                    "recommended": analysis.recommended_strategies,
                    "avoid": analysis.avoid_strategies,
                }
            except Exception:
                pass

        return {
            "primary": "UNKNOWN",
            "secondary": None,
            "confidence": 0.5,
            "trend": 0,
            "volatility": 50,
            "risk_mult": 1.0,
            "recommended": [],
            "avoid": [],
        }

    def _gather_all_signals(
        self,
        market_data: pd.DataFrame,
        fundamentals: Optional[Dict[str, Dict]],
        regime_info: Dict,
    ) -> List[Dict]:
        """Gather signals from all 20+ strategies."""
        all_signals = []

        # 1. Strategy Universe (10 strategies)
        if self._universe:
            try:
                strategies = self._universe.get_all_strategies()

                if isinstance(market_data.columns, pd.MultiIndex):
                    symbols = list(market_data.columns.get_level_values(0).unique())

                    for symbol in symbols[:50]:
                        prices = market_data[symbol]["Close"].dropna()
                        volumes = (
                            market_data[symbol].get("Volume", pd.Series()).dropna()
                        )
                        fund = fundamentals.get(symbol) if fundamentals else None

                        for strategy in strategies:
                            try:
                                signal = strategy.analyze(symbol, prices, volumes, fund)
                                if signal and signal.confidence >= 0.65:
                                    all_signals.append(
                                        {
                                            "source": "UNIVERSE",
                                            "strategy": strategy.name,
                                            "symbol": signal.symbol,
                                            "action": signal.action,
                                            "entry": signal.entry_price,
                                            "stop": signal.stop_loss,
                                            "target": signal.target,
                                            "confidence": signal.confidence,
                                            "reasoning": signal.reasoning,
                                        }
                                    )
                            except Exception:
                                continue
            except Exception:
                pass

        # 2. Institutional Strategies (10 strategies)
        if self._institutional:
            try:
                inst_signals = self._institutional.get_best_trades(
                    market_data, fundamentals, top_n=20
                )
                for sig in inst_signals:
                    all_signals.append(
                        {
                            "source": "INSTITUTIONAL",
                            "strategy": sig.strategy_name,
                            "symbol": sig.symbol,
                            "action": sig.direction,
                            "entry": sig.entry_price,
                            "stop": sig.stop_loss,
                            "target": sig.target_2,
                            "confidence": sig.conviction,
                            "reasoning": sig.edge,
                        }
                    )
            except Exception:
                pass

        # 3. High Risk High Reward
        if self._hrhr:
            try:
                hrhr_trades = self._hrhr.find_best_trades(
                    market_data, fundamentals, top_n=10
                )
                for trade in hrhr_trades:
                    all_signals.append(
                        {
                            "source": "HRHR",
                            "strategy": trade.setup_type,
                            "symbol": trade.symbol,
                            "action": trade.action,
                            "entry": trade.entry_price,
                            "stop": trade.stop_loss,
                            "target": trade.take_profit_2,
                            "confidence": trade.confidence,
                            "reasoning": ", ".join(trade.reasons),
                        }
                    )
            except Exception:
                pass

        # 4. Dip Buyer
        if self._dip_buyer:
            try:
                dips = self._dip_buyer.buy_the_dip(market_data, fundamentals, top_n=10)
                for dip in dips:
                    all_signals.append(
                        {
                            "source": "DIP_BUYER",
                            "strategy": dip.dip_type,
                            "symbol": dip.symbol,
                            "action": "BUY",
                            "entry": dip.entry_price,
                            "stop": dip.stop_loss,
                            "target": dip.target_2,
                            "confidence": 0.70,
                            "reasoning": ", ".join(dip.reasons),
                        }
                    )
            except Exception:
                pass

        return all_signals

    def _detect_smart_money(self, market_data: pd.DataFrame) -> Dict[str, Dict]:
        """Detect smart money activity for each symbol."""
        smart_money_map = {}

        if self._smart_money:
            try:
                signals = self._smart_money.scan_market(market_data)
                for sig in signals:
                    smart_money_map[sig.symbol] = {
                        "direction": sig.direction,
                        "confidence": sig.confidence,
                        "activity": sig.activity,
                    }
            except Exception:
                pass

        return smart_money_map

    def _rank_opportunities(
        self,
        signals: List[Dict],
        smart_money: Dict[str, Dict],
        regime_info: Dict,
        market_data: pd.DataFrame,
    ) -> List[Dict]:
        """
        Rank all opportunities by quality using Strategic Confluence.

        VAST INTELLIGENCE UPGRADE:
        - Hard Veto for Regime Mismatch
        - Smart Money Alignment for 'A' Grades
        - Stricter Scoring
        """
        for signal in signals:
            score = signal.get("confidence", 0.5)
            reasons = [signal.get("reasoning", "")]

            symbol = signal.get("symbol")
            strategy = signal.get("strategy", "")

            # 1. HARD REGIME VETO (The "Don't Be Dumb" Gate)
            # If the regime explicitly avoids this strategy type...
            if any(
                avoid.lower() in strategy.lower()
                for avoid in regime_info.get("avoid", [])
            ):
                # SYMMETRIC INTEL: Allow SELLs to survive as potential exits
                if signal.get("action") in ["SELL", "SHORT"]:
                    score *= 0.5
                    reasons.append(
                        f"Regime Avoids (Penalized but Kept for Exit): {strategy}"
                    )
                else:
                    # KILL BUYs
                    signal["score"] = 0.0
                    signal["grade"] = "F"
                    signal["reasoning"] = (
                        f"HARD VETO: Strategy {strategy} avoids regime {regime_info.get('primary')}"
                    )
                    continue

            # 2. Smart Money Alignment (The "Whale" Gate)
            is_sm_aligned = False
            if symbol in smart_money:
                sm = smart_money[symbol]

                # Check alignment
                if (signal.get("action") == "BUY" and sm["direction"] == "BULLISH") or (
                    signal.get("action") in ["SELL", "SHORT"]
                    and sm["direction"] == "BEARISH"
                ):
                    score += 0.15
                    is_sm_aligned = True
                    reasons.append(f"Smart Money Aligned ({sm['activity']})")

                # VAST: Penalize contra-smart-money heavily
                elif (
                    signal.get("action") == "BUY" and sm["direction"] == "BEARISH"
                ) or (
                    signal.get("action") in ["SELL", "SHORT"]
                    and sm["direction"] == "BULLISH"
                ):
                    score -= 0.25
                    reasons.append(f"CONTRA SMART MONEY ({sm['activity']})")

            signal["smart_money_aligned"] = is_sm_aligned

            # 3. Strategy Preference
            if any(
                rec.lower() in strategy.lower()
                for rec in regime_info.get("recommended", [])
            ):
                score += 0.10
                reasons.append("Regime Recommended")

            # 4. Risk/Reward Bonus
            entry = signal.get("entry", Decimal("0"))
            stop = signal.get("stop", Decimal("0"))
            target = signal.get("target", Decimal("0"))
            rr = 0

            if entry and stop and target:
                try:
                    risk = abs(float(entry) - float(stop))
                    reward = abs(float(target) - float(entry))
                    rr = reward / risk if risk > 0 else 0

                    if rr >= 5:  # Higher bar
                        score += 0.15
                    elif rr >= 3:
                        score += 0.10
                    elif rr >= 2.5:
                        score += 0.05

                    signal["risk_reward"] = rr
                except Exception:
                    signal["risk_reward"] = 0
            # 5. ML Predictive Boost (Phase 2 Upgrade)
            if self._predictive_model and symbol:
                try:
                    # Extract symbol data for ML
                    sym_data = pd.DataFrame()
                    if isinstance(market_data, pd.DataFrame):
                        if isinstance(market_data.columns, pd.MultiIndex):
                            if symbol in market_data.columns.get_level_values(0):
                                sym_data = market_data[symbol].copy()
                    elif isinstance(market_data, dict) and symbol in market_data:
                        sym_data = market_data[symbol]

                    if not sym_data.empty and len(sym_data) > 20:
                        # Adaptive: Calculate Volatility (20-period std dev of close returns)
                        returns = sym_data["close"].pct_change()
                        volatility = returns.rolling(20).std().iloc[-1]

                        # Get Dynamic Thresholds
                        bull_thresh, bear_thresh = MLConfig.get_adaptive_thresholds(
                            volatility
                        )

                        forecast = self._predictive_model.get_forecast(sym_data)
                        ml_prob = forecast.get("probability", 0.5)

                        # Directional Confluence Logic
                        action = signal.get("action", "BUY")
                        # Use centralized thresholds
                        is_bullish_prediction = ml_prob > bull_thresh
                        is_bearish_prediction = ml_prob < bear_thresh

                        # Boost if Aligned
                        if (action == "BUY" and is_bullish_prediction) or (
                            action in ["SELL", "SHORT"] and is_bearish_prediction
                        ):
                            score *= MLConfig.BOOST_MULTIPLIER
                            reasons.append(f"ML BOOST (Aligned Conf={ml_prob:.2f})")

                        # Penalize if Divergent
                        elif (action == "BUY" and is_bearish_prediction) or (
                            action in ["SELL", "SHORT"] and is_bullish_prediction
                        ):
                            score *= MLConfig.PENALTY_MULTIPLIER
                            reasons.append(f"ML PENALTY (Divergent Conf={ml_prob:.2f})")
                except Exception as e:
                    logger.debug(f"ML scoring failed for {symbol}: {e}")

            # 6. Strategic Confluence Cap
            # If not aligned with Smart Money, cap score at 0.75 (Max 'B+')
            if not is_sm_aligned and score > 0.75:
                score = 0.75
                reasons.append("Capped: No Smart Money Support")

            signal["score"] = min(1.0, max(0.0, score))
            signal["reasoning"] = "; ".join(filter(None, reasons))

        # Sort by score
        signals.sort(key=lambda x: x.get("score", 0), reverse=True)

        return signals

    def _generate_trade(
        self,
        candidate: Dict,
        market_data: pd.DataFrame,
        regime_info: Dict,
        portfolio_value: float,
    ) -> Optional[AutonomousTrade]:
        """Generate validated trade from candidate."""
        symbol = candidate.get("symbol")
        entry = candidate.get("entry")
        stop = candidate.get("stop")
        target = candidate.get("target")

        if not all([symbol, entry, stop, target]):
            return None

        # Ensure Decimal
        if not isinstance(entry, Decimal):
            entry = Decimal(str(entry))
        if not isinstance(stop, Decimal):
            stop = Decimal(str(stop))
        if not isinstance(target, Decimal):
            target = Decimal(str(target))

        # Calculate risk/reward
        risk = abs(entry - stop)
        reward = abs(target - entry)
        rr = reward / risk if risk > 0 else Decimal("0")

        if float(rr) < self.MIN_RISK_REWARD:
            return None

        risk_pct = (risk / entry) * 100
        reward_pct = (reward / entry) * 100

        # Position sizing
        # Risk-based: risk 1% of portfolio per trade
        risk_amount = Decimal(str(portfolio_value)) * Decimal("0.01")
        shares = int(risk_amount / risk) if risk > 0 else 0

        if shares <= 0:
            return None

        position_value = shares * entry
        position_pct = position_value / Decimal(str(portfolio_value))

        # Cap position size
        if position_pct > self.MAX_POSITION_SIZE:
            shares = int(
                (Decimal(str(portfolio_value)) * self.MAX_POSITION_SIZE) / entry
            )
            position_pct = self.MAX_POSITION_SIZE

        # Apply regime risk multiplier
        position_pct *= Decimal(str(regime_info.get("risk_mult", 1.0)))

        # Guardian check
        all_checks = True
        if self._guardian:
            try:
                prices = (
                    market_data[symbol]["Close"].dropna()
                    if isinstance(market_data.columns, pd.MultiIndex)
                    else pd.Series()
                )
                result = self._guardian.analyze_trade(
                    symbol,
                    candidate.get("action", "BUY"),
                    float(entry),
                    float(stop),
                    float(target),
                    prices,
                )
                all_checks = result.trade_allowed
            except Exception:
                pass

        # Determine grade
        score = candidate.get("score", 0)
        conf = candidate.get("confidence", 0.7)

        if score >= 0.85 and float(rr) >= 4:
            grade = "A+"
        elif score >= 0.75 and float(rr) >= 3:
            grade = "A"
        elif score >= 0.65 and float(rr) >= 2.5:
            grade = "B"
        else:
            grade = "C"

        if grade == "C":
            return None  # Only A+ to B grades

        # Multiple take profit levels
        t1 = entry + reward * Decimal("0.4")
        t2 = target
        t3 = entry + reward * Decimal("1.5")

        # Max loss in dollars
        max_loss = shares * risk

        return AutonomousTrade(
            timestamp=datetime.utcnow(),
            symbol=symbol,
            action=candidate.get("action", "BUY"),
            entry_price=entry.quantize(Decimal("0.01")),
            entry_type="LIMIT",
            position_size=position_pct.quantize(Decimal("0.001")),
            shares=shares,
            stop_loss=stop.quantize(Decimal("0.01")),
            take_profit_1=t1.quantize(Decimal("0.01")),
            take_profit_2=t2.quantize(Decimal("0.01")),
            take_profit_3=t3.quantize(Decimal("0.01")),
            risk_pct=risk_pct.quantize(Decimal("0.1")),
            reward_pct=reward_pct.quantize(Decimal("0.1")),
            risk_reward=rr.quantize(Decimal("0.1")),
            max_loss_dollars=max_loss.quantize(Decimal("0.01")),
            strategy_used=candidate.get("strategy", "UNKNOWN"),
            regime=regime_info.get("primary", "UNKNOWN"),
            confidence=conf,
            grade=grade,
            reasoning=[candidate.get("reasoning", "Strong setup")],
            smart_money_aligned=candidate.get("smart_money_aligned", False),
            all_checks_passed=all_checks,
        )

    def get_stats(self) -> Dict[str, Any]:
        """Get brain statistics."""
        return {
            "trades_generated": self.trades_generated,
            "trades_executed": self.trades_executed,
            "winning_trades": self.winning_trades,
            "win_rate": (
                self.winning_trades / self.trades_executed
                if self.trades_executed > 0
                else 0
            ),
        }


# Singleton
_brain: Optional[AutonomousTradingBrain] = None


def get_autonomous_brain() -> AutonomousTradingBrain:
    """Get or create the Autonomous Trading Brain."""
    global _brain
    if _brain is None:
        _brain = AutonomousTradingBrain()
    return _brain
